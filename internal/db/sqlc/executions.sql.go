// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: executions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createExecution = `-- name: CreateExecution :one
INSERT INTO executions (exec_id, order_id, cl_ord_id, exec_type, ord_status, symbol, side, order_qty, last_shares, last_px, leaves_qty, cum_qty, avg_px, transact_time, text)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) RETURNING exec_id, order_id, cl_ord_id, exec_type, ord_status, symbol, side, order_qty, last_shares, last_px, leaves_qty, cum_qty, avg_px, transact_time, text
`

type CreateExecutionParams struct {
	ExecID       string         `json:"exec_id"`
	OrderID      string         `json:"order_id"`
	ClOrdID      pgtype.Text    `json:"cl_ord_id"`
	ExecType     string         `json:"exec_type"`
	OrdStatus    string         `json:"ord_status"`
	Symbol       string         `json:"symbol"`
	Side         string         `json:"side"`
	OrderQty     pgtype.Numeric `json:"order_qty"`
	LastShares   pgtype.Numeric `json:"last_shares"`
	LastPx       pgtype.Numeric `json:"last_px"`
	LeavesQty    pgtype.Numeric `json:"leaves_qty"`
	CumQty       pgtype.Numeric `json:"cum_qty"`
	AvgPx        pgtype.Numeric `json:"avg_px"`
	TransactTime int64          `json:"transact_time"`
	Text         pgtype.Text    `json:"text"`
}

func (q *Queries) CreateExecution(ctx context.Context, arg CreateExecutionParams) (Execution, error) {
	row := q.db.QueryRow(ctx, createExecution,
		arg.ExecID,
		arg.OrderID,
		arg.ClOrdID,
		arg.ExecType,
		arg.OrdStatus,
		arg.Symbol,
		arg.Side,
		arg.OrderQty,
		arg.LastShares,
		arg.LastPx,
		arg.LeavesQty,
		arg.CumQty,
		arg.AvgPx,
		arg.TransactTime,
		arg.Text,
	)
	var i Execution
	err := row.Scan(
		&i.ExecID,
		&i.OrderID,
		&i.ClOrdID,
		&i.ExecType,
		&i.OrdStatus,
		&i.Symbol,
		&i.Side,
		&i.OrderQty,
		&i.LastShares,
		&i.LastPx,
		&i.LeavesQty,
		&i.CumQty,
		&i.AvgPx,
		&i.TransactTime,
		&i.Text,
	)
	return i, err
}

const deleteExecution = `-- name: DeleteExecution :one
DELETE
FROM executions
WHERE exec_id = $1 RETURNING exec_id, order_id, cl_ord_id, exec_type, ord_status, symbol, side, order_qty, last_shares, last_px, leaves_qty, cum_qty, avg_px, transact_time, text
`

func (q *Queries) DeleteExecution(ctx context.Context, execID string) (Execution, error) {
	row := q.db.QueryRow(ctx, deleteExecution, execID)
	var i Execution
	err := row.Scan(
		&i.ExecID,
		&i.OrderID,
		&i.ClOrdID,
		&i.ExecType,
		&i.OrdStatus,
		&i.Symbol,
		&i.Side,
		&i.OrderQty,
		&i.LastShares,
		&i.LastPx,
		&i.LeavesQty,
		&i.CumQty,
		&i.AvgPx,
		&i.TransactTime,
		&i.Text,
	)
	return i, err
}

const getExecution = `-- name: GetExecution :one
SELECT exec_id, order_id, cl_ord_id, exec_type, ord_status, symbol, side, order_qty, last_shares, last_px, leaves_qty, cum_qty, avg_px, transact_time, text
FROM executions
WHERE exec_id = $1
`

func (q *Queries) GetExecution(ctx context.Context, execID string) (Execution, error) {
	row := q.db.QueryRow(ctx, getExecution, execID)
	var i Execution
	err := row.Scan(
		&i.ExecID,
		&i.OrderID,
		&i.ClOrdID,
		&i.ExecType,
		&i.OrdStatus,
		&i.Symbol,
		&i.Side,
		&i.OrderQty,
		&i.LastShares,
		&i.LastPx,
		&i.LeavesQty,
		&i.CumQty,
		&i.AvgPx,
		&i.TransactTime,
		&i.Text,
	)
	return i, err
}

const listExecutions = `-- name: ListExecutions :many
SELECT exec_id, order_id, cl_ord_id, exec_type, ord_status, symbol, side, order_qty, last_shares, last_px, leaves_qty, cum_qty, avg_px, transact_time, text
FROM executions
ORDER BY exec_id
`

func (q *Queries) ListExecutions(ctx context.Context) ([]Execution, error) {
	rows, err := q.db.Query(ctx, listExecutions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Execution{}
	for rows.Next() {
		var i Execution
		if err := rows.Scan(
			&i.ExecID,
			&i.OrderID,
			&i.ClOrdID,
			&i.ExecType,
			&i.OrdStatus,
			&i.Symbol,
			&i.Side,
			&i.OrderQty,
			&i.LastShares,
			&i.LastPx,
			&i.LeavesQty,
			&i.CumQty,
			&i.AvgPx,
			&i.TransactTime,
			&i.Text,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExecution = `-- name: UpdateExecution :one
UPDATE executions
SET cl_ord_id     = COALESCE($2, cl_ord_id),
    exec_type     = COALESCE($3, exec_type),
    ord_status    = COALESCE($4, ord_status),
    symbol        = COALESCE($5, symbol),
    side          = COALESCE($6, side),
    order_qty     = COALESCE($7, order_qty),
    last_shares   = COALESCE($8, last_shares),
    last_px       = COALESCE($9, last_px),
    leaves_qty    = COALESCE($10, leaves_qty),
    cum_qty       = COALESCE($11, cum_qty),
    avg_px        = COALESCE($12, avg_px),
    transact_time = COALESCE($13, transact_time),
    text          = COALESCE($14, text)
WHERE exec_id = $1 RETURNING exec_id, order_id, cl_ord_id, exec_type, ord_status, symbol, side, order_qty, last_shares, last_px, leaves_qty, cum_qty, avg_px, transact_time, text
`

type UpdateExecutionParams struct {
	ExecID       string         `json:"exec_id"`
	ClOrdID      pgtype.Text    `json:"cl_ord_id"`
	ExecType     string         `json:"exec_type"`
	OrdStatus    string         `json:"ord_status"`
	Symbol       string         `json:"symbol"`
	Side         string         `json:"side"`
	OrderQty     pgtype.Numeric `json:"order_qty"`
	LastShares   pgtype.Numeric `json:"last_shares"`
	LastPx       pgtype.Numeric `json:"last_px"`
	LeavesQty    pgtype.Numeric `json:"leaves_qty"`
	CumQty       pgtype.Numeric `json:"cum_qty"`
	AvgPx        pgtype.Numeric `json:"avg_px"`
	TransactTime int64          `json:"transact_time"`
	Text         pgtype.Text    `json:"text"`
}

func (q *Queries) UpdateExecution(ctx context.Context, arg UpdateExecutionParams) (Execution, error) {
	row := q.db.QueryRow(ctx, updateExecution,
		arg.ExecID,
		arg.ClOrdID,
		arg.ExecType,
		arg.OrdStatus,
		arg.Symbol,
		arg.Side,
		arg.OrderQty,
		arg.LastShares,
		arg.LastPx,
		arg.LeavesQty,
		arg.CumQty,
		arg.AvgPx,
		arg.TransactTime,
		arg.Text,
	)
	var i Execution
	err := row.Scan(
		&i.ExecID,
		&i.OrderID,
		&i.ClOrdID,
		&i.ExecType,
		&i.OrdStatus,
		&i.Symbol,
		&i.Side,
		&i.OrderQty,
		&i.LastShares,
		&i.LastPx,
		&i.LeavesQty,
		&i.CumQty,
		&i.AvgPx,
		&i.TransactTime,
		&i.Text,
	)
	return i, err
}
