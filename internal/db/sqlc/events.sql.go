// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: events.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    order_id, type, side, order_qty, leaves_qty, exec_qty, price, instrument
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8
         )
    RETURNING id, order_id, timestamp, type, side, instrument, order_qty, leaves_qty, exec_qty, price
`

type CreateEventParams struct {
	OrderID    string         `json:"order_id"`
	Type       string         `json:"type"`
	Side       string         `json:"side"`
	OrderQty   pgtype.Numeric `json:"order_qty"`
	LeavesQty  pgtype.Numeric `json:"leaves_qty"`
	ExecQty    pgtype.Numeric `json:"exec_qty"`
	Price      pgtype.Numeric `json:"price"`
	Instrument string         `json:"instrument"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.OrderID,
		arg.Type,
		arg.Side,
		arg.OrderQty,
		arg.LeavesQty,
		arg.ExecQty,
		arg.Price,
		arg.Instrument,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.Timestamp,
		&i.Type,
		&i.Side,
		&i.Instrument,
		&i.OrderQty,
		&i.LeavesQty,
		&i.ExecQty,
		&i.Price,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :one
DELETE FROM events
WHERE id = $1
    RETURNING id, order_id, timestamp, type, side, instrument, order_qty, leaves_qty, exec_qty, price
`

func (q *Queries) DeleteEvent(ctx context.Context, id uuid.UUID) (Event, error) {
	row := q.db.QueryRow(ctx, deleteEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.Timestamp,
		&i.Type,
		&i.Side,
		&i.Instrument,
		&i.OrderQty,
		&i.LeavesQty,
		&i.ExecQty,
		&i.Price,
	)
	return i, err
}

const getEvent = `-- name: GetEvent :one
SELECT id, order_id, timestamp, type, side, instrument, order_qty, leaves_qty, exec_qty, price FROM events
WHERE id = $1
`

func (q *Queries) GetEvent(ctx context.Context, id uuid.UUID) (Event, error) {
	row := q.db.QueryRow(ctx, getEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.Timestamp,
		&i.Type,
		&i.Side,
		&i.Instrument,
		&i.OrderQty,
		&i.LeavesQty,
		&i.ExecQty,
		&i.Price,
	)
	return i, err
}

const listEvents = `-- name: ListEvents :many
SELECT id, order_id, timestamp, type, side, instrument, order_qty, leaves_qty, exec_qty, price FROM events
ORDER BY timestamp DESC
`

func (q *Queries) ListEvents(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.Timestamp,
			&i.Type,
			&i.Side,
			&i.Instrument,
			&i.OrderQty,
			&i.LeavesQty,
			&i.ExecQty,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events
SET
    order_id = COALESCE($2, order_id),
    type = COALESCE($3, type),
    side = COALESCE($4, side),
    order_qty = COALESCE($5, order_qty),
    leaves_qty = COALESCE($6, leaves_qty),
    exec_qty = COALESCE($7, exec_qty),
    price = COALESCE($8, price)
WHERE id = $1
    RETURNING id, order_id, timestamp, type, side, instrument, order_qty, leaves_qty, exec_qty, price
`

type UpdateEventParams struct {
	ID        uuid.UUID      `json:"id"`
	OrderID   pgtype.Text    `json:"order_id"`
	Type      pgtype.Text    `json:"type"`
	Side      pgtype.Text    `json:"side"`
	OrderQty  pgtype.Numeric `json:"order_qty"`
	LeavesQty pgtype.Numeric `json:"leaves_qty"`
	ExecQty   pgtype.Numeric `json:"exec_qty"`
	Price     pgtype.Numeric `json:"price"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.ID,
		arg.OrderID,
		arg.Type,
		arg.Side,
		arg.OrderQty,
		arg.LeavesQty,
		arg.ExecQty,
		arg.Price,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.Timestamp,
		&i.Type,
		&i.Side,
		&i.Instrument,
		&i.OrderQty,
		&i.LeavesQty,
		&i.ExecQty,
		&i.Price,
	)
	return i, err
}
